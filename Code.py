# -*- coding: utf-8 -*-
"""untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/mahtabnik-polito/16d5799d4cfd154756dc4ad8c4d84c38/untitled4.ipynb
"""

class cell:

    def __init__(self, parent,  x=0, y=0, dist=0 ):
        self.x = x
        self.y = y
        self.dist = dist
        if isinstance(parent, cell):
          self.parent = parent

# checks whether given position is
# inside the board

def isInside(x, y, N):
    if (x >= 1 and x <= N and
            y >= 1 and y <= N):
        return True
    return False

# Method returns minimum step to reach
# target position


def minStepToReachTarget(knightpos,
                         targetpos, N):

    # all possible movements for the knight
    dx = [2, 2, -2, -2, 1, 1, -1, -1]
    dy = [1, -1, 1, -1, 2, -2, 2, -2]

    queue = []
    node_visited=[]

    # push starting position of knight
    # with 0 distance
    queue.append(cell(0,knightpos[0], knightpos[1], 0))

    # make all cell unvisited
    visited = [[False for i in range(N + 1)]
               for j in range(N + 1)]

    # visit starting state
    visited[knightpos[0]][knightpos[1]] = True

    # loop until we have one element in queue
    while(len(queue) > 0):

        t = queue[0]
        queue.pop(0)


        # if current cell is equal to target
        # cell, return its distance
        if(t.x == targetpos[0] and
           t.y == targetpos[1]):
            return t.dist , node_visited

        # iterate for all reachable states
        for i in range(8):

            x = t.x + dx[i]
            y = t.y + dy[i]

            if(isInside(x, y, N) and not visited[x][y]):
                visited[x][y] = True
                queue.append(cell(t,x, y, t.dist + 1))
                node_visited.append(cell(t,x, y , t.dist + 1))

# Driver Code
if __name__ == '__main__':

    import graphviz as gv
    import pylab

    g1 = gv.Graph(format='png')
    # Number of the cells in the board
    N = 30
    knightpos = [1, 1]
    targetpos = [5, 5]

    # Function call
    dist, q = minStepToReachTarget(knightpos,
                               targetpos, N)
    for i in range(0 , len(q)):
      g1.node(f"{q[i].parent.x},{q[i].parent.y}")
      g1.node(f"{q[i].x},{q[i].y}")
      g1.edge(f"{q[i].parent.x},{q[i].parent.y}" ,f"{q[i].x},{q[i].y}" )
      print(q[i].x , q[i].y , q[i].dist , q[i].parent.x , q[i].parent.y)
    print(dist)


g1.view()
print(g1.source)
filename = g1.render(filename='img/g1')
pylab.savefig('filename.png')